"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const graphql_tools_1 = require("graphql-tools");
class TraceCollector {
    constructor() {
        this.resolverCalls = [];
    }
    requestDidStart() {
        this.startWallTime = new Date();
        this.startHrTime = process.hrtime();
    }
    executionDidStart() {
    }
    requestDidEnd() {
        this.duration = process.hrtime(this.startHrTime);
        this.endWallTime = new Date();
    }
}
exports.TraceCollector = TraceCollector;
function instrumentSchemaForTracing(schema) {
    if (schema._instrumentedForTracing) {
        return schema;
    }
    schema._instrumentedForTracing = true;
    graphql_tools_1.forEachField(schema, instrumentField);
    return schema;
}
exports.instrumentSchemaForTracing = instrumentSchemaForTracing;
function instrumentField(field) {
    const fieldResolver = field.resolve;
    const instrumentedFieldResolver = (source, args, context, info) => {
        const traceCollector = context._traceCollector;
        const resolverCall = {
            path: info.path,
            fieldName: info.fieldName,
            parentType: info.parentType,
            returnType: info.returnType,
            startOffset: process.hrtime(traceCollector.startHrTime)
        };
        function resolverCallDidFinish() {
            resolverCall.endOffset = process.hrtime(traceCollector.startHrTime);
        }
        traceCollector.resolverCalls.push(resolverCall);
        // If no resolver has been defined for a field, use the default field resolver
        // (which matches the behavior of graphql-js when there is no explicit resolve function defined).
        // TODO: Find a way to respect custom field resolvers, see https://github.com/graphql/graphql-js/pull/865
        try {
            const result = (fieldResolver || graphql_1.defaultFieldResolver)(source, args, context, info);
            whenResultIsFinished(result, resolverCallDidFinish);
            return result;
        }
        catch (error) {
            resolverCallDidFinish();
            throw error;
        }
    };
    field.resolve = instrumentedFieldResolver;
}
function whenResultIsFinished(result, callback) {
    if (result === null || typeof result === 'undefined') {
        callback();
    }
    else if (typeof result.then === 'function') {
        result.then(callback, callback);
    }
    else if (Array.isArray(result)) {
        const promises = [];
        result.forEach(value => {
            if (value && typeof value.then === 'function') {
                promises.push(value);
            }
            if (promises.length > 0) {
                Promise.all(promises).then(callback, callback);
            }
            else {
                callback();
            }
        });
    }
    else {
        callback();
    }
}
//# sourceMappingURL=instrumentation.js.map